{"version":3,"sources":["mine.js","Home.js","App.js","reportWebVitals.js","index.js"],"names":["pushRand","sb","arr","Uint8Array","i","rand","parseInt","Math","floor","random","getRand","pushArray","lastMineTx","mining_account","account","eos_rpc","a","get_table_rows","code","scope","table","lower_bound","upper_bound","state_res","last_mine_tx","rows","length","doWork","difficulty","good","last","itr","console","error","substr","last_mine_buf","Buffer","from","is_wam","log","start","Date","getTime","Serialize","SerialBuffer","textEncoder","TextEncoder","textDecoder","TextDecoder","pushName","Array","rand_arr","hash","crypto","createHash","update","array","slice","hex_digest","digest","end","rand_str","map","toString","join","mine_work","rpc","JsonRpc","fetch","Home","ual","transaction","mine","activeUser","accountName","user_nonce","actions","name","authorization","actor","permission","data","miner","nonce","signTransaction","blocksBehind","expireSeconds","broadcast","sign","r","alert","transactionId","JSON","stringify","SEND_OPTIONS","TRANSACTIONS","useState","setAccount","sendOption","useEffect","run","get_account","acc","openLoginModal","showModal","activeAuthenticator","onClick","logout","renderLogoutButton","call","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","myChain","chainId","rpcEndpoints","protocol","host","port","anchor","Anchor","appName","wax","Wax","MyUALConsumer","withUAL","ReactDOM","render","StrictMode","chains","authenticators","document","getElementById"],"mappings":"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","file":"static/js/main.2649b4f5.chunk.js","sourcesContent":["import { Buffer } from \"buffer\";\nimport crypto from \"crypto-browserify\";\nimport { Serialize } from \"eosjs\";\nimport { TextDecoder, TextEncoder } from \"text-encoding\";\nimport { Int64LE } from \"int64-buffer\";\n\n\n/* Utility functions */\nconst getRand = () => {\n    const arr = new Uint8Array(8);\n    for (let i=0; i < 8; i++){\n        const rand = parseInt(Math.floor(Math.random() * 255));\n        arr[i] = rand;\n    }\n    return arr;\n};\n\nconst pushRand = (sb) => {\n    const arr = getRand();\n    sb.pushArray(arr);\n    return arr;\n};\n\n\n/* uint8array to / from hex strings */\nconst fromHexString = hexString =>\n    new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));\n\nconst toHexString = bytes =>\n    bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n\nconst nameToInt = (name) => {\n    const sb = new Serialize.SerialBuffer({\n        textEncoder: new TextEncoder,\n        textDecoder: new TextDecoder\n    });\n\n    sb.pushName(name);\n\n    const name_64 = new Int64LE(sb.array);\n\n    return name_64 + '';\n}\n\nconst nameToArray = (name) => {\n    const sb = new Serialize.SerialBuffer({\n        textEncoder: new TextEncoder,\n        textDecoder: new TextDecoder\n    });\n\n    sb.pushName(name);\n\n    return sb.array;\n}\n\nconst intToName = (int) => {\n    int = new Int64LE(int);\n\n    const sb = new Serialize.SerialBuffer({\n        textEncoder: new TextEncoder,\n        textDecoder: new TextDecoder\n    });\n\n    sb.pushArray(int.toArray());\n\n    const name = sb.getName();\n\n    return name;\n}\n\n\nconst setPlayerData = async (federation_account, account, eos_api, tag='', avatar_id=0, permission = 'active') => {\n    const actions = [];\n    actions.push({\n        account: federation_account,\n        name: 'setavatar',\n        authorization: [{\n            actor: account,\n            permission: permission\n        }],\n        data: {\n            account,\n            avatar_id\n        }\n    });\n    actions.push({\n        account: federation_account,\n        name: 'settag',\n        authorization: [{\n            actor: account,\n            permission: permission\n        }],\n        data: {\n            account,\n            tag\n        }\n    });\n\n    const res = await eos_api.transact({\n        actions\n    }, {\n        blocksBehind: 3,\n        expireSeconds: 90,\n    });\n\n    return res;\n};\n\nconst setTagData = async (federation_account, account, eos_api, tag, permission = 'active') => {\n    const actions = [];\n    actions.push({\n        account: federation_account,\n        name: 'settag',\n        authorization: [{\n            actor: account,\n            permission: permission\n        }],\n        data: {\n            account,\n            tag\n        }\n    });\n\n    const res = await eos_api.transact({\n        actions\n    }, {\n        blocksBehind: 3,\n        expireSeconds: 90,\n    });\n\n    return res;\n};\n\nconst getPlayerData = async (federation_account, account, eos_rpc, aa_api) => {\n\n    const player_res = await eos_rpc.get_table_rows({\n        code: federation_account,\n        scope: federation_account,\n        table: 'players',\n        lower_bound: account,\n        upper_bound: account\n    });\n\n    const player_data = {\n        tag: '',\n        avatar: ''\n    };\n\n    if (player_res.rows.length){\n        player_data.tag = player_res.rows[0].tag;\n        if (player_res.rows[0].avatar > 0){\n            const asset = await aa_api.getAsset(player_res.rows[0].avatar);\n            if (asset){\n                player_data.avatar = asset;\n            }\n        }\n    }\n\n    return player_data;\n\n};\n\n\nconst getPlanets = async (federation_account, mining_account, eos_rpc) => {\n    const planets_res = await eos_rpc.get_table_rows({code: federation_account, scope: federation_account, table: 'planets', limit: 100});\n\n    const planets = [];\n    for (let p = 0; p < planets_res.rows.length; p++){\n        const pr = planets_res.rows[p];\n        if (pr.planet_name === 'bina.world'){continue;}\n\n        try {\n            pr.metadata = JSON.parse(pr.metadata);\n        }\n        catch (e){\n            pr.metadata = {};\n        }\n\n        // trilium reserve\n        const planet_reserve = await eos_rpc.get_currency_balance('alien.worlds', pr.planet_name, 'TLM');\n        pr.reserve = planet_reserve[0];\n\n        // mining pot\n        const mining_pot_res = await eos_rpc.get_table_rows({\n            code: mining_account,\n            scope: pr.planet_name,\n            table: 'state3'\n        });\n        if (mining_pot_res.rows.length){\n            pr.mining_pot = {\n                fill_rate: mining_pot_res.rows[0].fill_rate,\n                bucket_total: mining_pot_res.rows[0].bucket_total,\n                mine_bucket: mining_pot_res.rows[0].mine_bucket,\n                allocated_percentage: 80\n            };\n        }\n\n        const [dac_precision, dac_symbol] = pr.dac_symbol.split(',');\n        pr.total_stake = (pr.total_stake / Math.pow(10, parseInt(dac_precision))).toFixed(dac_precision);\n        pr.total_stake = `${pr.total_stake} ${dac_symbol}`;\n\n        pr.active = !!pr.active;\n        planets.push(pr);\n    }\n\n    return planets;\n};\n\nconst getBag = async (mining_account, account, eos_rpc, aa_api) => {\n    const bag_res = await eos_rpc.get_table_rows({code: mining_account, scope: mining_account, table: 'bags', lower_bound: account, upper_bound: account});\n    const bag = [];\n    if (bag_res.rows.length){\n        const items_p = bag_res.rows[0].items.map((item_id) => {\n            return aa_api.getAsset(item_id);\n        });\n        return await Promise.all(items_p);\n    }\n    return bag;\n}\n\nconst setBag = async (mining_account, account, items, eos_api, permission = 'active') => {\n    const actions = [{\n        account: mining_account,\n        name: 'setbag',\n        authorization: [{\n            actor: account,\n            permission: permission,\n        }],\n        data: {\n            account,\n            items: items.slice(0, 3)\n        }\n    }];\n    const res = await eos_api.transact({\n        actions\n    }, {\n        blocksBehind: 3,\n        expireSeconds: 90,\n    });\n\n    return res;\n}\n\nconst getLandById = async (federation_account, land_id, eos_rpc, aa_api) => {\n    try {\n        const land_res = await eos_rpc.get_table_rows({code: federation_account, scope: federation_account, table: 'landregs', lower_bound: land_id, upper_bound: land_id});\n        let landowner = 'federation';\n        if (land_res.rows.length){\n            landowner = land_res.rows[0].owner;\n        }\n\n        if (!landowner) {\n            throw new Error(`Land owner not found for land id ${land_id}`);\n        }\n\n        const land_asset = await aa_api.getAsset(land_id);\n        // const land_data = await land_asset.toObject();\n\n        land_asset.data.planet = intToName(land_asset.data.planet);\n\n        // make sure these attributes are present\n        land_asset.data.img = land_asset.data.img || '';\n        land_asset.owner = land_asset.owner || landowner;\n\n        return land_asset;\n    }\n    catch (e){\n        console.log(`Error in getLandById ${e.message}`);\n        return null;\n    }\n}\n\nconst getLand = async (federation_account, mining_account, account, eos_rpc, aa_api) => {\n    try {\n        const miner_res = await eos_rpc.get_table_rows({code: mining_account, scope: mining_account, table: 'miners', lower_bound: account, upper_bound: account});\n        let land_id;\n        if (miner_res.rows.length === 0){\n            return null;\n        }\n        else {\n            land_id = miner_res.rows[0].current_land;\n        }\n\n        return await getLandById(federation_account, land_id, eos_rpc, aa_api);\n    }\n    catch (e) {\n        console.error(`Failed to get land - ${e.message}`);\n        return null;\n    }\n}\n\nconst setLand = async (mining_account, account, land_id, eos_api, permission = 'active') => {\n    const actions = [{\n        account: mining_account,\n        name: 'setland',\n        authorization: [{\n            actor: account,\n            permission: permission,\n        }],\n        data: {\n            account,\n            land_id\n        }\n    }];\n    const res = await eos_api.transact({\n        actions\n    }, {\n        blocksBehind: 3,\n        expireSeconds: 90,\n    });\n\n    return res;\n}\n\nconst getLandByPlanet = async (planet_name, atomic_endpoint, collection, schema = 'land.worlds') => {\n    const planet_int = nameToInt(planet_name);\n\n    // https://test.wax.api.atomicassets.io/atomicassets/v1/assets?collection_name=test.worlds&schema_name=land.worlds&data.planet=6310955965768028672\n\n    const url = `${atomic_endpoint}/atomicassets/v1/assets?collection_name=${collection}&schema_name=${schema}&data.planet=${planet_int}`;\n    const res = await fetch(url);\n\n    const json = await res.json();\n\n    return json.data.map(d => {\n        // console.log('ddd', d)\n        let commission = d.mutable_data.commission || 0;\n        // console.log(commission);\n        return {\n            id: d.asset_id,\n            name: d.name,\n            owner: d.owner,\n            commission: (commission / 100).toFixed(2)\n        }\n    });\n}\n\n\nconst getLandMiningParams = (land) => {\n    const mining_params = {\n        delay: 0,\n        difficulty: 0,\n        ease: 0\n    };\n\n    mining_params.delay += land.data.delay;\n    mining_params.difficulty += land.data.difficulty;\n    mining_params.ease += land.data.ease;\n\n    return mining_params;\n};\n\nconst getBagMiningParams = (bag) => {\n    const mining_params = {\n        delay: 0,\n        difficulty: 0,\n        ease: 0\n    };\n\n    let min_delay = 65535;\n\n    for (let b=0; b < bag.length; b++){\n        if (bag[b].data.delay < min_delay){\n            min_delay = bag[b].data.delay;\n        }\n        mining_params.delay += bag[b].data.delay;\n        mining_params.difficulty += bag[b].data.difficulty;\n        mining_params.ease += bag[b].data.ease / 10;\n    }\n\n    if (bag.length === 2){\n        mining_params.delay -= parseInt(min_delay / 2);\n    }\n    else if (bag.length === 3){\n        mining_params.delay -= min_delay;\n    }\n\n    return mining_params;\n};\n\n/* Return number of ms before we can next mine */\nconst getNextMineDelay = async (mining_account, account, params, eos_rpc) => {\n    const state_res = await eos_rpc.get_table_rows({\n        code: mining_account,\n        scope: mining_account,\n        table: 'miners',\n        lower_bound: account,\n        upper_bound: account\n    });\n\n    let ms_until_mine = -1;\n    const now = new Date().getTime();\n    console.log(`Delay = ${params.delay}`);\n\n    if (state_res.rows.length && state_res.rows[0].last_mine_tx !== '0000000000000000000000000000000000000000000000000000000000000000'){\n        console.log(`Last mine was at ${state_res.rows[0].last_mine}, now is ${new Date()}`);\n        const last_mine_ms = Date.parse(state_res.rows[0].last_mine + '.000Z');\n        ms_until_mine = last_mine_ms + (params.delay * 1000) - now;\n\n        if (ms_until_mine < 0){\n            ms_until_mine = 0;\n        }\n    }\n    console.log(`ms until next mine ${ms_until_mine}`);\n\n    return ms_until_mine;\n};\n\nconst lastMineTx = async (mining_account, account, eos_rpc) => {\n    const state_res = await eos_rpc.get_table_rows({\n        code: mining_account,\n        scope: mining_account,\n        table: 'miners',\n        lower_bound: account,\n        upper_bound: account\n    });\n    let last_mine_tx = '0000000000000000000000000000000000000000000000000000000000000000';\n    if (state_res.rows.length){\n        last_mine_tx = state_res.rows[0].last_mine_tx;\n    }\n\n    return last_mine_tx;\n};\n\nconst doWork = async ({mining_account, account, difficulty, last_mine_tx}) => {\n    let good = false, last = 0, itr = 0, rand = 0, hash, sb, hex_digest, rand_arr;\n\n    if (!last_mine_tx){\n        console.error(`Please provide last mine tx`);\n        return;\n    }\n    last_mine_tx = last_mine_tx.substr(0, 16); // only first 8 bytes of txid\n    const last_mine_buf = Buffer.from(last_mine_tx, 'hex');\n    const is_wam = account.substr(-4) === '.wam';\n    // const is_wam = true;\n\n    console.log(`Performing work with difficulty ${difficulty}, last tx is ${last_mine_tx}...`);\n    if (is_wam){\n        console.log(`Using WAM account`);\n    }\n\n    const start = (new Date()).getTime();\n\n    while (!good){\n        sb = new Serialize.SerialBuffer({\n            textEncoder: new TextEncoder,\n            textDecoder: new TextDecoder\n        });\n        sb.pushName(account);\n        sb.pushArray(Array.from(last_mine_buf));\n        rand_arr = pushRand(sb);\n        hash = crypto.createHash(\"sha256\");\n        hash.update(sb.array.slice(0, 24));\n        hex_digest = hash.digest('hex');\n        // console.log(hex_digest);\n        if (is_wam){\n            // easier for .wam accounts\n            good = hex_digest.substr(0, 4) === '0000';\n        }\n        else {\n            // console.log(`non-wam account, mining is harder`)\n            good = hex_digest.substr(0, 6) === '000000';\n        }\n\n        if (good){\n            if (is_wam){\n                last = parseInt(hex_digest.substr(4, 1), 16);\n            }\n            else {\n                last = parseInt(hex_digest.substr(6, 1), 16);\n            }\n            good &= (last <= difficulty);\n            // console.log(hex_digest);\n        }\n        itr++;\n\n        if (itr % 50000000 === 0){\n            console.log(`Still mining - tried ${itr} iterations`);\n        }\n\n        if (!good){\n            // delete sb;\n            // delete hash;\n        }\n\n    }\n    const end = (new Date()).getTime();\n\n    // console.log(sb.array.slice(0, 20));\n    // const rand_str = Buffer.from(sb.array.slice(16, 24)).toString('hex');\n    const rand_str = Array.from(rand_arr).map(i => ('0' + i.toString(16)).slice(-2)).join('');\n\n    console.log(`Found hash in ${itr} iterations with ${account} ${rand_str}, last = ${last}, hex_digest ${hex_digest} taking ${(end-start) / 1000}s`)\n    const mine_work = {account, rand_str, hex_digest};\n\n    return mine_work;\n};\n\n\nconst doWorkWorker = async (mining_params) => {\n    console.log('mining_params', mining_params)\n\n    const _doWorkWorker = async (_message) => {\n        const getRand = () => {\n            const arr = new Uint8Array(8);\n            for (let i=0; i < 8; i++){\n                const rand = Math.floor(Math.random() * 255);\n                arr[i] = rand;\n            }\n            return arr;\n        };\n\n        const toHex = (buffer) => {\n            return [...new Uint8Array (buffer)]\n                .map (b => b.toString (16).padStart (2, \"0\"))\n                .join (\"\");\n        };\n\n        // console.log('in worker')\n        let {mining_account, account, account_str, difficulty, last_mine_tx, last_mine_arr, sb} = _message.data;\n        account = account.slice(0, 8);\n\n        const is_wam = account_str.substr(-4) === '.wam';\n\n        let good = false, itr = 0, rand = 0, hash, hex_digest, rand_arr, last;\n\n        console.log(`Performing work with difficulty ${difficulty}, last tx is ${last_mine_tx}...`);\n        if (is_wam){\n            console.log(`Using WAM account`);\n        }\n\n        const start = (new Date()).getTime();\n\n        while (!good){\n            rand_arr = getRand();\n\n            // console.log('combining', account, last_mine_arr, rand_arr);\n            const combined = new Uint8Array(account.length + last_mine_arr.length + rand_arr.length);\n            combined.set(account);\n            combined.set(last_mine_arr, account.length);\n            combined.set(rand_arr, account.length + last_mine_arr.length);\n\n            // hash = crypto.createHash(\"sha256\");\n            // hash.update(combined.slice(0, 24));\n            // hex_digest = hash.digest('hex');\n            // console.log('combined slice', combined.slice(0, 24))\n            hash = await crypto.subtle.digest('SHA-256', combined.slice(0, 24));\n            // console.log(hash);\n            hex_digest = toHex(hash);\n            // console.log(hex_digest);\n            if (is_wam){\n                // easier for .wam accounts\n                good = hex_digest.substr(0, 4) === '0000';\n            }\n            else {\n                // console.log(`non-wam account, mining is harder`)\n                good = hex_digest.substr(0, 6) === '000000';\n            }\n\n            if (good){\n                if (is_wam){\n                    last = parseInt(hex_digest.substr(4, 1), 16);\n                }\n                else {\n                    last = parseInt(hex_digest.substr(6, 1), 16);\n                }\n                good &= (last <= difficulty);\n                // console.log(hex_digest, good);\n            }\n            itr++;\n\n            if (itr % 1000000 === 0){\n                console.log(`Still mining - tried ${itr} iterations`);\n            }\n\n            if (!good){\n                hash = null;\n            }\n\n        }\n        const end = (new Date()).getTime();\n\n        // console.log(sb.array.slice(0, 20));\n        // const rand_str = Buffer.from(sb.array.slice(16, 24)).toString('hex');\n        const rand_str = toHex(rand_arr);\n\n        console.log(`Found hash in ${itr} iterations with ${account} ${rand_str}, last = ${last}, hex_digest ${hex_digest} taking ${(end-start) / 1000}s`)\n        const mine_work = {account: account_str, rand_str, hex_digest};\n\n        this.postMessage(mine_work);\n\n        return mine_work;\n    }\n\n    // console.log(_doWorkWorker.toString());\n\n    mining_params.last_mine_tx = mining_params.last_mine_tx.substr(0, 16); // only first 8 bytes of txid\n    mining_params.last_mine_arr = fromHexString(mining_params.last_mine_tx);\n\n    const sb = new Serialize.SerialBuffer({\n        textEncoder: new TextEncoder,\n        textDecoder: new TextDecoder\n    });\n    mining_params.sb = sb;\n\n    mining_params.account_str = mining_params.account;\n    mining_params.account = nameToArray(mining_params.account);\n\n    let b = new Blob([\"onmessage =\" + _doWorkWorker.toString()], {type: \"text/javascript\"});\n    let worker = new Worker(URL.createObjectURL(b));\n    worker.postMessage(mining_params);\n    return await new Promise(resolve => worker.onmessage = e => resolve(e.data));\n};\n\nfunction sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nconst getBountyFromTx = async (transaction_id, miner, hyperion_endpoints) => {\n    // temporary fix\n    await sleep(4000);\n\n    return new Promise(async (resolve, reject) => {\n        for (let i = 0; i < 30; i++){\n            for (let h = 0; h < hyperion_endpoints.length; h++){\n                const hyp = hyperion_endpoints[h];\n                if (hyp != 'https://wax.eosusa.news')\n                {\n                    try {\n                        const url = `${hyp}/v2/history/get_transaction?id=${transaction_id}`\n                        const t_res = await fetch(url);\n                        const t_json = await t_res.json();\n                        // console.log(t_json)\n                        if (t_json.executed){\n                            let amount = 0\n                            const amounts = t_json.actions.filter(a => a.act.name === 'transfer').map(a => a.act).filter(a => a.data.to === miner).map(a => a.data.quantity)\n                            amounts.forEach(a => amount += parseFloat(a))\n                            if (amount > 0){\n                                resolve(`${amount.toFixed(4)} TLM`)\n                                return\n                            }\n                        }\n                    }\n                    catch (e){\n                        console.log(e.message)\n                    }\n                }\n\n                await sleep(1000);\n            }\n\n            await sleep(2000);\n        }\n\n        resolve('UNKNOWN');\n    });\n}\n\n\n\nconst claim = (mining_account, account, account_permission, mine_data, hyperion_endpoints, eos_api) => {\n    return new Promise(async (resolve, reject) => {\n        try {\n            const actions = [{\n                account: mining_account,\n                name: 'mine',\n                authorization: [{\n                    actor: account,\n                    permission: account_permission,\n                }],\n                data: mine_data\n            }];\n            const res = await eos_api.transact({\n                actions\n            }, {\n                blocksBehind: 3,\n                expireSeconds: 90,\n            });\n\n            console.log(res.transaction_id)\n\n            resolve(res.transaction_id);\n        }\n        catch (e){\n            console.log(`Failed to push mine results ${e.message}`);\n            reject(e);\n        }\n    });\n}\n\nconst processRandomQueue = async (mining_account, eos_api, permission = 'active') => {\n    const actions = [{\n        account: mining_account,\n        name: 'procrand',\n        authorization: [{\n            actor: mining_account,\n            permission\n        }],\n        data: { }\n    }];\n    const res = await eos_api.transact({\n        actions\n    }, {\n        blocksBehind: 3,\n        expireSeconds: 90,\n    });\n\n    return res;\n\n}\n\nconst setLandCommission = async (federation_account, owner, land_id, profit_share, eos_api, permission = 'active') => {\n    const actions = [{\n        account: federation_account,\n        name: 'setprofitshr',\n        authorization: [{\n            actor: owner,\n            permission\n        }],\n        data: {\n            owner,\n            land_id,\n            profit_share\n        }\n    }];\n\n    const res = await eos_api.transact({\n        actions\n    }, {\n        blocksBehind: 3,\n        expireSeconds: 90,\n    });\n\n    return res;\n};\n\nexport { setPlayerData, setTagData, getBag, setBag, getLand, getLandById, setLand, getPlanets, getLandByPlanet, getPlayerData, getLandMiningParams, getBagMiningParams, getNextMineDelay, lastMineTx, doWork, doWorkWorker, processRandomQueue, setLandCommission, claim, getBountyFromTx }\n","import React, { useEffect, useState } from \"react\";\r\nimport { JsonRpc } from \"eosjs\";\r\nimport * as mine from \"./mine\";\r\n\r\nconst rpc = new JsonRpc(\"https://wax.greymass.com\", { fetch });\r\nconst Home = ({ ual }) => {\r\n  const transaction = async () => {\r\n    try {\r\n        const last_mine_tx = await mine.lastMineTx(\"m.federation\", ual.activeUser.accountName, rpc);// (mining_account, account, eos_rpc)\r\n        const user_nonce = await mine.doWork(\"m.federation\", ual.activeUser.accountName, 0, last_mine_tx );\r\n\r\n        const actions = {\r\n      actions: [\r\n        // {\r\n        //     account: \"waxengineers\",\r\n        //     name: \"cpu\",\r\n        //     authorization: [\r\n        //         {\r\n        //             actor: \"waxengineers\",\r\n        //             permission: \"active\",\r\n        //         },\r\n        //     ],\r\n        //     data: {\r\n        //         name: ual.activeUser.accountName,\r\n        //     },\r\n        // },\r\n        {\r\n            account: \"m.federation\",\r\n            name: \"mine\",\r\n            authorization: [\r\n                {\r\n                    actor: ual.activeUser.accountName,\r\n                    permission: \"active\",\r\n                },\r\n            ],\r\n            data: {\r\n                miner: ual.activeUser.accountName,\r\n                nonce: user_nonce,\r\n          },\r\n\r\n        },\r\n        // {\r\n        //     account: \"alien.worlds\",\r\n        //     name: \"transfer\",\r\n        //     authorization: [\r\n        //         {\r\n        //             actor: user_account,\r\n        //             permission: \"active\",\r\n        //         },\r\n        //     ],\r\n        //     data: {\r\n        //         from: user_account,\r\n        //         memo: \"Limitlesswax CPU Payment\",\r\n        //         quantity: tlm_fee,\r\n        //         to: collector,\r\n        //     },\r\n        // },\r\n      ],\r\n    };\r\n\r\n        const r = await ual.activeUser.signTransaction(actions, {\r\n          blocksBehind: 5,\r\n          expireSeconds: 300,\r\n          broadcast: true,\r\n          sign: true,\r\n        });\r\n        console.log(r);\r\n        alert(\"Transaction ID: \" + r.transactionId);\r\n    } catch (e) {\r\n        console.error(e);\r\n        // process.exit();\r\n        alert(e);\r\n        console.log(JSON.stringify(e));\r\n    }\r\n  };\r\n\r\n  const SEND_OPTIONS = {\r\n    self: \"Start\",\r\n  };\r\n\r\n  const TRANSACTIONS = {\r\n    [SEND_OPTIONS.self]: transaction,\r\n\r\n  };\r\n\r\n  const [account, setAccount] = useState();\r\n  const [sendOption, setSendOption] = useState(SEND_OPTIONS.self);\r\n\r\n\r\nuseEffect(() => {\r\n  const run = async () => {\r\n    if (ual.activeUser) {\r\n      try {\r\n        const acc = await rpc.get_account(ual.activeUser.accountName);\r\n        setAccount(acc);\r\n      } catch (e) {\r\n          console.error(e);\r\n          // process.exit();\r\n          console.log(JSON.stringify(e));\r\n      }\r\n\r\n    }\r\n  };\r\n  run();\r\n}, [ual.activeUser]);\r\n\r\n\r\n  const openLoginModal = () => {\r\n    if (!ual.activeUser) {\r\n      ual.showModal();\r\n    }\r\n  };\r\n\r\n  const renderLoginButton = () => {\r\n    return (\r\n      <div>\r\n        <button onClick={openLoginModal}>Login</button>\r\n        <br />\r\n      </div>\r\n    );\r\n  };\r\n\r\n  const renderLogoutButton = () => {\r\n    if (!!ual.activeUser && !!ual.activeAuthenticator) {\r\n      return (\r\n        <div>\r\n          <br />\r\n          <button onClick={ual.logout}>Logout</button>\r\n          <br />\r\n          <br />\r\n        </div>\r\n      );\r\n    }\r\n  };\r\n\r\n  const renderName = () => {\r\n    return ual.activeUser && account ? (\r\n      <div>\r\n        {ual.activeUser.accountName} <br />\r\n      </div>\r\n    ) : null;\r\n  };\r\n\r\n\r\n  const renderSubmitButton = () => {\r\n    return (\r\n      <div>\r\n        <button onClick={() => TRANSACTIONS[sendOption].call()}>\r\n          {sendOption}\r\n        </button>\r\n      </div>\r\n    );\r\n  };\r\n\r\n\r\n  return (\r\n    <div>\r\n      <h1>CPU</h1>\r\n      {ual.activeUser ? renderName() : null}\r\n      {ual.activeUser ? renderLogoutButton() : renderLoginButton()}\r\n      {ual.activeUser ? renderSubmitButton() : null}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Home;\r\n","import \"./App.css\";\nimport Home from \"./Home\";\n\nfunction App({ ual }) {\n  return (\n    <div className=\"App\">\n      <Home ual={ual} />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport { UALProvider, withUAL } from \"ual-reactjs-renderer\";\nimport { Anchor } from \"ual-anchor\";\nimport { Wax } from \"@eosdacio/ual-wax\";\n\nconst myChain = {\n  chainId: \"1064487b3cd1a897ce03ae5b6a865651747e2e152090f99c1d19d44e01aea5a4\",\n  rpcEndpoints: [\n    {\n      protocol: \"https\",\n      host: \"wax.greymass.com\",\n      port: \"443\",\n    },\n  ],\n};\n\n// const myChain = {\n//   chainId: \"f16b1833c747c43682f4386fca9cbb327929334a762755ebec17f6f23c9b8a12\",\n//   rpcEndpoints: [\n//     {\n//       protocol: \"https\",\n//       host: \"testnet.wax.eosdetroit.io\",\n//       port: \"443\",\n//     },\n//   ],\n// };\n\nconst anchor = new Anchor([myChain], { appName: \"cpu\" });\nconst wax = new Wax([myChain], { appName: \"cpu\" });\n\nconst MyUALConsumer = withUAL(App);\n\nReactDOM.render(\n  <React.StrictMode>\n    <UALProvider\n      chains={[myChain]}\n      authenticators={[anchor, wax]}\n      appName={\"cpu\"}\n    >\n      <MyUALConsumer />\n    </UALProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}